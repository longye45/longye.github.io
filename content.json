{"meta":{"title":"ly随笔","subtitle":null,"description":"寻光者","author":"longye45","url":"https://longye45.github.io"},"pages":[{"title":"","date":"2017-10-30T12:05:13.268Z","updated":"2017-10-30T12:05:13.268Z","comments":false,"path":"categories/index.html","permalink":"https://longye45.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-10-30T12:04:45.926Z","updated":"2017-10-30T12:04:45.926Z","comments":false,"path":"tags/index.html","permalink":"https://longye45.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"国密算法SM3的Java与JavaScript实现","slug":"国密加密算法的Java与JavaScript实现","date":"2017-12-04T01:29:37.428Z","updated":"2017-12-04T07:50:31.664Z","comments":true,"path":"2017/12/04/国密加密算法的Java与JavaScript实现/","link":"","permalink":"https://longye45.github.io/2017/12/04/国密加密算法的Java与JavaScript实现/","excerpt":"","text":"前言最近项目中需要对数据进行加密处理，由于项目的特殊性要求，加密统一采用国密算法进行加密。网上对国密算法的资料有限，且没有找到对应的JavaScript加密代码，无奈之下只得自己实现。加密的算法文档在国家密码管理局官网上可以查找到，此次的算法实现仅限于SM3与SM4的代码实现，SM2由于项目未做特殊要求因此还未来得及实现。 SM3加密的实现SM3密码杂凑算法简介 SM3算法是一种验证签名类算法，类似于MD5或SHA1等算法,适用于商用密码应用中的数字签名和验证、消息认证码的生成与验证以及随机数的生成， 可满足多种密码应用的安全需求。 SM3杂凑过程1.数据填充将原数据二进制进行填充，填充后的消息m′ 的比特长度为512的倍数。2.消息扩展将填充后的消息m′按512比特进行分组,将每组消息分组B(i)按一定方法扩展生成132个字，每个字为四个字节。3.迭代压缩按照一定规律进行64次迭代压缩，压缩后的值存入8个字节寄存器里面。4得到杂凑值最终计算出256位杂凑值 SM3代码实现过程java中的SM3实现代码中 getEncrpResult（） 方法是获取杂凑值的方法，方法的返回值是一个整型数组，大部分的杂凑值为了便于查看与比较，通常采用十六进制的字符串进行表示，本类也同样提供实现方法，实现方法是 getStringEncrpResult（） 。其他方法均为以上方法的子方法，由于设计较为底层的算法故不加赘述，具体请参照官方算法说明文档。1234567public int[] getEncrpResult() &#123; fillBinDatas();// 填充 ExtendedPacket();// 扩展 IterationMethod();// 迭代压缩 return result; &#125; 12345678910public String getStringEncrpResult()&#123; int[] rs = getEncrpResult(); String string = \"\"; for (int i = 0; i &lt; rs.length; i++) &#123; string += Integer.toHexString(rs[i]) + \" \"; &#125; return string;&#125; JavaScript中的SM3实现由于Java代码的完成时间较早，JavaScript的实现代码是从Java代码移植过来的，方法命名大同小异，因此不加赘述。加密方法为 getEncrpResult（） 和 getStringEncrpResult（） 。12345678me.getEncrpResult = function() &#123; me.init(); fillBinDatas();// 填充 ExtendedPacket();// 扩展 IterationMethod();// 迭代压缩 return me.result; &#125; 123456789101112me.getStringEncrpResult = function() &#123; var rs = me.getEncrpResult(); var string = \"\"; var res = new Uint32Array(me.result.length); copyArray(rs, 0, res, 0, rs.length); for (var i = 0; i &lt; rs.length; i++) &#123; string += res[i].toString(16) + \" \"; &#125; return string; &#125; SM3加密的使用方法SM3加密的Java使用本人水平有限无法熟练处理线程安全问题，为了稳定运行只能牺牲性能采用实例化后调用的方式进行。由于底层计算都是位运算实际使用情况尚可，以下是在Java中的使用方式：12SM3Encrp sm3 = new SM3Encrp(new byte[] &#123; 0x61, 0x62, 0x63, (byte) 0xff &#125;);String sm3Code = s.getStringEncrpResult(); 除了以上构造方法，还提供输入流和字符串的构造方法重载，基本上满足了项目中的使用。 SM3加密的JavaScript使用由于前台多是处理字符串和二进制数据，故统一采用传递二进制的方式进行杂凑计算。如果有求字符串杂凑值的必要可以调用以下方法转换为二进制byte数组进行使用123456789101112131415161718192021222324252627282930313233343536/** * 字符串转byte数组 * * @param &#123;*字符串&#125; * str */function stringToByte(str)&#123; var bytes = new Array(); var len, c; len = str.length; for (var i = 0; i &lt; len; i++) &#123; c = str.charCodeAt(i); if (c &gt;= 0x010000 &amp;&amp; c &lt;= 0x10FFFF) &#123; bytes.push(((c &gt;&gt; 18) &amp; 0x07) | 0xF0); bytes.push(((c &gt;&gt; 12) &amp; 0x3F) | 0x80); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if (c &gt;= 0x000800 &amp;&amp; c &lt;= 0x00FFFF) &#123; bytes.push(((c &gt;&gt; 12) &amp; 0x0F) | 0xE0); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); &#125; else if (c &gt;= 0x000080 &amp;&amp; c &lt;= 0x0007FF) &#123; bytes.push(((c &gt;&gt; 6) &amp; 0x1F) | 0xC0); bytes.push((c &amp; 0x3F) | 0x80); &#125; else &#123; bytes.push(c &amp; 0xFF); &#125; &#125; return bytes;&#125; 完整的使用过程如下：12345678var sm = new SM3Entrpt([0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61,0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x64]); var result = sm.getStringEncrpResult(); 如果要求字符串的杂凑值，使用方法如下：123var str = \"测试代码\";var sm = new SM3Entrpt(stringToByte(str));var result = sm.getStringEncrpResult(); 小结 九层之台起于累土，千里之行始于足下。 愿别人的收获中也有属于自己的耕耘。","categories":[{"name":"算法编程","slug":"算法编程","permalink":"https://longye45.github.io/categories/算法编程/"}],"tags":[{"name":"加密","slug":"加密","permalink":"https://longye45.github.io/tags/加密/"},{"name":"Java","slug":"Java","permalink":"https://longye45.github.io/tags/Java/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://longye45.github.io/tags/JavaScript/"}]},{"title":"test","slug":"test","date":"2017-10-29T15:25:41.000Z","updated":"2017-10-30T03:07:59.209Z","comments":true,"path":"2017/10/29/test/","link":"","permalink":"https://longye45.github.io/2017/10/29/test/","excerpt":"","text":"测试以下这是一篇测试文档1$ hexo new \"My New Post\"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-10-29T11:48:48.211Z","updated":"2017-10-30T12:11:37.232Z","comments":true,"path":"2017/10/29/hello-world/","link":"","permalink":"https://longye45.github.io/2017/10/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hello","slug":"hello","permalink":"https://longye45.github.io/categories/hello/"}],"tags":[{"name":"test","slug":"test","permalink":"https://longye45.github.io/tags/test/"}]}]}